// SEDNL - Copyright (c) 2013 Jeremy S. Cochoy
//
// This software is provided 'as-is', without any express or implied warranty.
// In no event will the authors be held liable for any damages arising from
// the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
//     1. The origin of this software must not be misrepresented; you must not
//        claim that you wrote the original software. If you use this software
//        in a product, an acknowledgment in the product documentation would
//        be appreciated but is not required.
//
//     2. Altered source versions must be plainly marked as such, and must not
//        be misrepresented as being the original software.
//
//     3. This notice may not be removed or altered from any source
//        distribution.

#ifndef TCP_SERVER_HPP_
#define TCP_SERVER_HPP_

#include "SEDNL/sednlfwd.hpp"

#include "SEDNL/Export.hpp"
#include "SEDNL/SocketInterface.hpp"
#include "SEDNL/SocketHelp.hpp"

#ifdef SEDNL_WINDOWS

#include <winsock2.h>
#include <Ws2tcpip.h>
#include <stdio.h>

#else /* SEDNL_WINDOWS */

#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <unistd.h>

#endif /* SEDNL_WINDOWS */

namespace SedNL
{

////////////////////////////////////////////////////////////
//! \brief Bind a server socket (to allow listening for
//!        incoming connections).
////////////////////////////////////////////////////////////
class SEDNL_API TCPServer : public SocketInterface
{
public:
    //! \brief Create an empty TCPServer.
    TCPServer() noexcept;

    //! \brief Close the connection if needed.
    ~TCPServer() noexcept;

    //! \brief Create a server connection from a SocketAddress.
    //!
    //! Calling this constructor is the same as creating an
    //! empty TCPServer, then calling TCPServer::connect().
    //!
    //! \param[in] socket_address Describe the port on wich the server
    //!                           will bind.
    TCPServer(const SocketAddress &socket_address);

    //! \brief Create a server connection from a SocketAddress.
    //!
    //! Create a 'server' socket, and bind it to the \a socket_address
    //! given. It allow listening for incoming connection through an
    //! EventListener object.
    //!
    //! \param[in] socket_address Describe the port on wich the server
    //!                           will bind.
    void connect(const SocketAddress &socket_address);

    //! \brief Close the connection.
    //!
    //! This method is thread safe, and can be called in a
    //! callback given to EventConsumer.
    virtual void disconnect() noexcept;

private:
    //! \brief The current listener.
    EventListener *m_listener;

    //! \brief Close the socket, and set the state to disconnected,
    //!        without any check.
    void unsafe_disconnect() noexcept;

    //! \brief Disconnect, using the mutex, but without telling the
    //!        EventListener that this connection will be closed.
    void safe_disconnect() noexcept;

    friend class EventListener;
};

} // namespace SedNL

#endif /* !TCP_SERVER_HPP_ */

////////////////////////////////////////////////////////////
//!
//! \class SedNL::TCPServer
//!
//! The TCPServer class is a TCP listener. It allow accepting
//! incoming connections.
//! It's basicaly the object used in a server application.
//! Client applications use a TCPClient object.
//! (But you can mix TCPClient and TCPServer objects in the same
//! application if you want.)
//!
//! Here is a basic use of a TCPServer :
//!
//! \code
//!
//! //Create a server
//! TCPServer server(SocketAddress(4242));
//!
//! //Create an event listener
//! EventListener listener(server);
//! listener.on_connect().set_function(my_on_connect);
//!
//! EventConsumer consumer(listener);
//! consumer.on_disconnect().set_function(my_on_disconnect);
//! consumer.bind("apples").set_function(my_apples); //'apples' events
//! consumer.on_event().set_function(my_on_event); //All other events
//!
//! //Listen for incoming connections and other events
//! listener.run(); //Launch a thread
//! //Consume vents generated by the listener.
//! consumer.run(); // Launch a thread
//!
//! //Do some stuff in the main thread.
//!
//! listener.join();
//! consumer.join();
//!
//! \endcode
////////////////////////////////////////////////////////////
